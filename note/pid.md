#### 1、PID闭环系统

PID分为3个部分：

-   `P`：比例环节；
-   `I`：积分环节；
-   `D`：微分环节；

其中 **P** 比例满足以下公式：
$$
K_p*e(t)
$$
因此比例作用相当于某一时刻的**偏差**（`err`）与比例系数$$K_p$$的乘积。

`I`积分则是误差在一定时间内的和，满足以下公式；
$$
K_i\int^t_0 e(\tau)d\tau
$$

`D`**微分**则是误差变化曲线某处的导数，或者说是某一点的斜率，因此这里需要引入微分:
$$
K_d {de(t)\over dt}
$$


因此，分别改变 PID 其中一项会导致以下变化：

| 参数    | 上升时间 | 超调量 | 响应时间 | 稳态误差 | 稳定性     |
| ------- | -------- | ------ | -------- | -------- | ---------- |
| $$K_p$$ | 减少     | 增加   | 小变化   | 减少     | 降级       |
| $$K_i$$ | 减少     | 增加   | 增加     | 消除     | 降级       |
| $$K_d$$ | 微小变化 | 减少   | 减少     | 无影响   | 越小越稳定 |

因此在PID中的输入输出关系为：
$$
u(t) = K_pe(t) + K_i\int^t_0 e(\tau)d\tau + K_d {de(t)\over dt}
$$
$$K_p$$是比例增益； $$K_i$$是积分增益； $$K_d$$是微分增益；



#### 2、PID离散化

在实际的数字系统中，需要对PID算法离散化，这就是**位置式PID**：
$$
u(k) = K_p{e(k)} + K_i\sum^k_{i=1}{e(i)}\Delta{t} + K_d {e(k)-e(k-1)\over\Delta{t}}
$$
**可以这么理解：比例环节将误差线性放大，积分环节将误差值的积分放大，微分环节将两次的误差值放大，所有的值相加得到最终输出值**。

简化一下就变为**增量式PID**:
$$
\Delta u(k) = K_p({e(k)-e(k-1)}) + K_ie(k) + K_d ({e(k)-2e(k-1)+e(k-2)})
$$
由公式可以看出，**增量式的表达结果和最近三次的偏差有关，这样就大大提高了系统的稳定性**。需要注意的是最终的输出结果应该为 $$u(k)+\Delta u(k)$$ 。

**两者的区别**：

（1）位置式PID控制的输出与整个过去的状态有关，用到了误差的累加值；而增量式PID的输出只与当前拍和前两拍的误差有关，因此位置式PID控制的累积误差相对更大;

（2）增量式PID控制输出的是控制量增量，并无积分作用，因此该方法适用于执行机构带积分部件的对象，如步进电机等，而位置式PID适用于执行机构不带积分部件的对象，如电液伺服阀。

（3）由于增量式PID输出的是控制量增量，如果计算机出现故障，误动作影响较小，而执行机构本身有记忆功能，可仍保持原位，不会严重影响系统的工作，而位置式的输出直接对应对象的输出，因此对系统影响较大。

#### 3、伪代码实现

```
previous_error := 0  //上一次偏差
integral := 0   //积分和

//循环 
//采样周期为dt
loop:
 //setpoint 设定值
 //measured_value 反馈值
    error := setpoint − measured_value //计算得到偏差
    integral := integral + error × dt //计算得到积分累加和
    derivative := (error − previous_error) / dt //计算得到微分
    output := Kp × error + Ki × integral + Kd × derivative //计算得到PID输出
    previous_error := error //保存当前偏差为下一次采样时所需要的历史偏差
    wait(dt) //等待下一次采用
    goto loop
```

#### 4、参考链接

https://www.cnblogs.com/zhjblogs/p/13731824.html
